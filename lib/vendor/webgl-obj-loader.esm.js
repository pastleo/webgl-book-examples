var e,t={d:(e,s)=>{for(var a in s)t.o(s,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:s[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},s={};t.d(s,{ah:()=>r,i1:()=>a,Ar:()=>i,F5:()=>l,Jc:()=>u,Kj:()=>n,NQ:()=>v,vK:()=>e,R9:()=>M,Ml:()=>m,LT:()=>p,cP:()=>d,i8:()=>b}),function(e){e.BYTE="BYTE",e.UNSIGNED_BYTE="UNSIGNED_BYTE",e.SHORT="SHORT",e.UNSIGNED_SHORT="UNSIGNED_SHORT",e.FLOAT="FLOAT"}(e||(e={}));class a extends Error{constructor(e){super(`found duplicate attribute: ${e.key}`)}}class r{constructor(e,t,s,a=!1){switch(this.key=e,this.size=t,this.type=s,this.normalized=a,s){case"BYTE":case"UNSIGNED_BYTE":this.sizeOfType=1;break;case"SHORT":case"UNSIGNED_SHORT":this.sizeOfType=2;break;case"FLOAT":this.sizeOfType=4;break;default:throw new Error(`Unknown gl type: ${s}`)}this.sizeInBytes=this.sizeOfType*t}}class i{constructor(...e){this.attributes=e,this.attributeMap={};let t=0,s=0;for(const r of e){if(this.attributeMap[r.key])throw new a(r);t%r.sizeOfType!=0&&(t+=r.sizeOfType-t%r.sizeOfType,console.warn("Layout requires padding before "+r.key+" attribute")),this.attributeMap[r.key]={attribute:r,size:r.size,type:r.type,normalized:r.normalized,offset:t},t+=r.sizeInBytes,s=Math.max(s,r.sizeOfType)}t%s!=0&&(t+=s-t%s,console.warn("Layout requires padding at the back")),this.stride=t;for(const t of e)this.attributeMap[t.key].stride=this.stride}}i.POSITION=new r("position",3,e.FLOAT),i.NORMAL=new r("normal",3,e.FLOAT),i.TANGENT=new r("tangent",3,e.FLOAT),i.BITANGENT=new r("bitangent",3,e.FLOAT),i.UV=new r("uv",2,e.FLOAT),i.MATERIAL_INDEX=new r("materialIndex",1,e.SHORT),i.MATERIAL_ENABLED=new r("materialEnabled",1,e.UNSIGNED_SHORT),i.AMBIENT=new r("ambient",3,e.FLOAT),i.DIFFUSE=new r("diffuse",3,e.FLOAT),i.SPECULAR=new r("specular",3,e.FLOAT),i.SPECULAR_EXPONENT=new r("specularExponent",3,e.FLOAT),i.EMISSIVE=new r("emissive",3,e.FLOAT),i.TRANSMISSION_FILTER=new r("transmissionFilter",3,e.FLOAT),i.DISSOLVE=new r("dissolve",1,e.FLOAT),i.ILLUMINATION=new r("illumination",1,e.UNSIGNED_SHORT),i.REFRACTION_INDEX=new r("refractionIndex",1,e.FLOAT),i.SHARPNESS=new r("sharpness",1,e.FLOAT),i.MAP_DIFFUSE=new r("mapDiffuse",1,e.SHORT),i.MAP_AMBIENT=new r("mapAmbient",1,e.SHORT),i.MAP_SPECULAR=new r("mapSpecular",1,e.SHORT),i.MAP_SPECULAR_EXPONENT=new r("mapSpecularExponent",1,e.SHORT),i.MAP_DISSOLVE=new r("mapDissolve",1,e.SHORT),i.ANTI_ALIASING=new r("antiAliasing",1,e.UNSIGNED_SHORT),i.MAP_BUMP=new r("mapBump",1,e.SHORT),i.MAP_DISPLACEMENT=new r("mapDisplacement",1,e.SHORT),i.MAP_DECAL=new r("mapDecal",1,e.SHORT),i.MAP_EMISSIVE=new r("mapEmissive",1,e.SHORT);class n{constructor(e,t){this.name="",this.indicesPerMaterial=[],this.materialsByIndex={},this.tangents=[],this.bitangents=[],(t=t||{}).materials=t.materials||{},t.enableWTextureCoord=!!t.enableWTextureCoord,this.vertexNormals=[],this.textures=[],this.indices=[],this.textureStride=t.enableWTextureCoord?3:2;const s=[],a=[],r=[],i=[],n={};let l=-1,c=0;const u={verts:[],norms:[],textures:[],hashindices:{},indices:[[]],materialIndices:[],index:0},h=/^v\s/,p=/^vn\s/,m=/^vt\s/,f=/^f\s/,d=/\s+/,M=/^usemtl/,b=e.split("\n");for(let e of b){if(e=e.trim(),!e||e.startsWith("#"))continue;const b=e.split(d);if(b.shift(),h.test(e))s.push(...b);else if(p.test(e))a.push(...b);else if(m.test(e)){let e=b;b.length>2&&!t.enableWTextureCoord?e=b.slice(0,2):2===b.length&&t.enableWTextureCoord&&e.push("0"),r.push(...e)}else if(M.test(e)){const e=b[0];e in n||(i.push(e),n[e]=i.length-1,n[e]>0&&u.indices.push([])),l=n[e],c=l}else if(f.test(e)){const e=o(b);for(const i of e)for(let e=0,n=i.length;e<n;e++){const n=i[e]+","+l;if(n in u.hashindices)u.indices[c].push(u.hashindices[n]);else{const o=i[e].split("/"),h=o.length-1;if(u.verts.push(+s[3*(+o[0]-1)+0]),u.verts.push(+s[3*(+o[0]-1)+1]),u.verts.push(+s[3*(+o[0]-1)+2]),r.length){const e=t.enableWTextureCoord?3:2;u.textures.push(+r[(+o[1]-1)*e+0]),u.textures.push(+r[(+o[1]-1)*e+1]),t.enableWTextureCoord&&u.textures.push(+r[(+o[1]-1)*e+2])}u.norms.push(+a[3*(+o[h]-1)+0]),u.norms.push(+a[3*(+o[h]-1)+1]),u.norms.push(+a[3*(+o[h]-1)+2]),u.materialIndices.push(l),u.hashindices[n]=u.index,u.indices[c].push(u.hashindices[n]),u.index+=1}}}}this.vertices=u.verts,this.vertexNormals=u.norms,this.textures=u.textures,this.vertexMaterialIndices=u.materialIndices,this.indices=u.indices[c],this.indicesPerMaterial=u.indices,this.materialNames=i,this.materialIndices=n,this.materialsByIndex={},t.calcTangentsAndBitangents&&this.calculateTangentsAndBitangents()}calculateTangentsAndBitangents(){console.assert(!!(this.vertices&&this.vertices.length&&this.vertexNormals&&this.vertexNormals.length&&this.textures&&this.textures.length),"Missing attributes for calculating tangents and bitangents");const e={tangents:[...new Array(this.vertices.length)].map((e=>0)),bitangents:[...new Array(this.vertices.length)].map((e=>0))},t=this.indices,s=this.vertices,a=this.vertexNormals,r=this.textures;for(let i=0;i<t.length;i+=3){const n=t[i+0],o=t[i+1],l=t[i+2],c=s[3*n+0],u=s[3*n+1],h=s[3*n+2],p=r[2*n+0],m=r[2*n+1],f=s[3*o+0],d=s[3*o+1],M=s[3*o+2],b=r[2*o+0],v=r[2*o+1],g=f-c,x=d-u,w=M-h,y=s[3*l+0]-c,T=s[3*l+1]-u,I=s[3*l+2]-h,A=b-p,E=v-m,S=r[2*l+0]-p,B=r[2*l+1]-m,_=A*B-E*S,F=1/Math.abs(_<1e-4?1:_),N=(g*B-y*E)*F,R=(x*B-T*E)*F,O=(w*B-I*E)*F,L=(y*A-g*S)*F,k=(T*A-x*S)*F,D=(I*A-w*S)*F,P=a[3*n+0],C=a[3*n+1],U=a[3*n+2],z=a[3*o+0],H=a[3*o+1],Y=a[3*o+2],G=a[3*l+0],j=a[3*l+1],W=a[3*l+2],K=N*P+R*C+O*U,X=N*z+R*H+O*Y,q=N*G+R*j+O*W,V=N-P*K,$=R-C*K,Z=O-U*K,J=N-z*X,Q=R-H*X,ee=O-Y*X,te=N-G*q,se=R-j*q,ae=O-W*q,re=Math.sqrt(V*V+$*$+Z*Z),ie=Math.sqrt(J*J+Q*Q+ee*ee),ne=Math.sqrt(te*te+se*se+ae*ae),oe=L*P+k*C+D*U,le=L*z+k*H+D*Y,ce=L*G+k*j+D*W,ue=L-P*oe,he=k-C*oe,pe=D-U*oe,me=L-z*le,fe=k-H*le,de=D-Y*le,Me=L-G*ce,be=k-j*ce,ve=D-W*ce,ge=Math.sqrt(ue*ue+he*he+pe*pe),xe=Math.sqrt(me*me+fe*fe+de*de),we=Math.sqrt(Me*Me+be*be+ve*ve);e.tangents[3*n+0]+=V/re,e.tangents[3*n+1]+=$/re,e.tangents[3*n+2]+=Z/re,e.tangents[3*o+0]+=J/ie,e.tangents[3*o+1]+=Q/ie,e.tangents[3*o+2]+=ee/ie,e.tangents[3*l+0]+=te/ne,e.tangents[3*l+1]+=se/ne,e.tangents[3*l+2]+=ae/ne,e.bitangents[3*n+0]+=ue/ge,e.bitangents[3*n+1]+=he/ge,e.bitangents[3*n+2]+=pe/ge,e.bitangents[3*o+0]+=me/xe,e.bitangents[3*o+1]+=fe/xe,e.bitangents[3*o+2]+=de/xe,e.bitangents[3*l+0]+=Me/we,e.bitangents[3*l+1]+=be/we,e.bitangents[3*l+2]+=ve/we}this.tangents=e.tangents,this.bitangents=e.bitangents}makeBufferData(e){const t=this.vertices.length/3,s=new ArrayBuffer(e.stride*t);s.numItems=t;const a=new DataView(s);for(let s=0,r=0;s<t;s++){r=s*e.stride;for(const t of e.attributes){const n=r+e.attributeMap[t.key].offset;switch(t.key){case i.POSITION.key:a.setFloat32(n,this.vertices[3*s],!0),a.setFloat32(n+4,this.vertices[3*s+1],!0),a.setFloat32(n+8,this.vertices[3*s+2],!0);break;case i.UV.key:a.setFloat32(n,this.textures[2*s],!0),a.setFloat32(n+4,this.textures[2*s+1],!0);break;case i.NORMAL.key:a.setFloat32(n,this.vertexNormals[3*s],!0),a.setFloat32(n+4,this.vertexNormals[3*s+1],!0),a.setFloat32(n+8,this.vertexNormals[3*s+2],!0);break;case i.MATERIAL_INDEX.key:a.setInt16(n,this.vertexMaterialIndices[s],!0);break;case i.AMBIENT.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setFloat32(n,t.ambient[0],!0),a.setFloat32(n+4,t.ambient[1],!0),a.setFloat32(n+8,t.ambient[2],!0);break}case i.DIFFUSE.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setFloat32(n,t.diffuse[0],!0),a.setFloat32(n+4,t.diffuse[1],!0),a.setFloat32(n+8,t.diffuse[2],!0);break}case i.SPECULAR.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setFloat32(n,t.specular[0],!0),a.setFloat32(n+4,t.specular[1],!0),a.setFloat32(n+8,t.specular[2],!0);break}case i.SPECULAR_EXPONENT.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setFloat32(n,t.specularExponent,!0);break}case i.EMISSIVE.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setFloat32(n,t.emissive[0],!0),a.setFloat32(n+4,t.emissive[1],!0),a.setFloat32(n+8,t.emissive[2],!0);break}case i.TRANSMISSION_FILTER.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setFloat32(n,t.transmissionFilter[0],!0),a.setFloat32(n+4,t.transmissionFilter[1],!0),a.setFloat32(n+8,t.transmissionFilter[2],!0);break}case i.DISSOLVE.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setFloat32(n,t.dissolve,!0);break}case i.ILLUMINATION.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setInt16(n,t.illumination,!0);break}case i.REFRACTION_INDEX.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setFloat32(n,t.refractionIndex,!0);break}case i.SHARPNESS.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setFloat32(n,t.sharpness,!0);break}case i.ANTI_ALIASING.key:{const e=this.vertexMaterialIndices[s],t=this.materialsByIndex[e];if(!t){console.warn('Material "'+this.materialNames[e]+'" not found in mesh. Did you forget to call addMaterialLibrary(...)?"');break}a.setInt16(n,t.antiAliasing?1:0,!0);break}}}}return s}makeIndexBufferData(){const e=new Uint16Array(this.indices);return e.numItems=this.indices.length,e}makeIndexBufferDataForMaterials(...e){const t=(new Array).concat(...e.map((e=>this.indicesPerMaterial[e]))),s=new Uint16Array(t);return s.numItems=t.length,s}addMaterialLibrary(e){for(const t in e.materials){if(!(t in this.materialIndices))continue;const s=e.materials[t],a=this.materialIndices[s.name];this.materialsByIndex[a]=s}}}function*o(e){if(e.length<=3)yield e;else if(4===e.length)yield[e[0],e[1],e[2]],yield[e[2],e[3],e[0]];else for(let t=1;t<e.length-1;t++)yield[e[0],e[t],e[t+1]]}class l{constructor(e){this.name=e,this.ambient=[0,0,0],this.diffuse=[0,0,0],this.specular=[0,0,0],this.emissive=[0,0,0],this.transmissionFilter=[0,0,0],this.dissolve=0,this.specularExponent=0,this.transparency=0,this.illumination=0,this.refractionIndex=1,this.sharpness=0,this.mapDiffuse={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""},this.mapAmbient={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""},this.mapSpecular={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""},this.mapSpecularExponent={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""},this.mapDissolve={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""},this.antiAliasing=!1,this.mapBump={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""},this.mapDisplacement={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""},this.mapDecal={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""},this.mapEmissive={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""},this.mapReflections=[]}}const c=new l("sentinel");class u{constructor(e){this.data=e,this.currentMaterial=c,this.materials={},this.parse()}parse_newmtl(e){const t=e[0];this.currentMaterial=new l(t),this.materials[t]=this.currentMaterial}parseColor(e){if("spectral"==e[0])throw new Error("The MTL parser does not support spectral curve files. You will need to convert the MTL colors to either RGB or CIEXYZ.");if("xyz"==e[0])throw new Error("The MTL parser does not currently support XYZ colors. Either convert the XYZ values to RGB or create an issue to add support for XYZ");if(3==e.length){const[t,s,a]=e;return[parseFloat(t),parseFloat(s),parseFloat(a)]}const t=parseFloat(e[0]);return[t,t,t]}parse_Ka(e){this.currentMaterial.ambient=this.parseColor(e)}parse_Kd(e){this.currentMaterial.diffuse=this.parseColor(e)}parse_Ks(e){this.currentMaterial.specular=this.parseColor(e)}parse_Ke(e){this.currentMaterial.emissive=this.parseColor(e)}parse_Tf(e){this.currentMaterial.transmissionFilter=this.parseColor(e)}parse_d(e){this.currentMaterial.dissolve=parseFloat(e.pop()||"0")}parse_illum(e){this.currentMaterial.illumination=parseInt(e[0])}parse_Ni(e){this.currentMaterial.refractionIndex=parseFloat(e[0])}parse_Ns(e){this.currentMaterial.specularExponent=parseInt(e[0])}parse_sharpness(e){this.currentMaterial.sharpness=parseInt(e[0])}parse_cc(e,t){t.colorCorrection="on"==e[0]}parse_blendu(e,t){t.horizontalBlending="on"==e[0]}parse_blendv(e,t){t.verticalBlending="on"==e[0]}parse_boost(e,t){t.boostMipMapSharpness=parseFloat(e[0])}parse_mm(e,t){t.modifyTextureMap.brightness=parseFloat(e[0]),t.modifyTextureMap.contrast=parseFloat(e[1])}parse_ost(e,t,s){for(;e.length<3;)e.push(s.toString());t.u=parseFloat(e[0]),t.v=parseFloat(e[1]),t.w=parseFloat(e[2])}parse_o(e,t){this.parse_ost(e,t.offset,0)}parse_s(e,t){this.parse_ost(e,t.scale,1)}parse_t(e,t){this.parse_ost(e,t.turbulence,0)}parse_texres(e,t){t.textureResolution=parseFloat(e[0])}parse_clamp(e,t){t.clamp="on"==e[0]}parse_bm(e,t){t.bumpMultiplier=parseFloat(e[0])}parse_imfchan(e,t){t.imfChan=e[0]}parse_type(e,t){t.reflectionType=e[0]}parseOptions(e){const t={colorCorrection:!1,horizontalBlending:!0,verticalBlending:!0,boostMipMapSharpness:0,modifyTextureMap:{brightness:0,contrast:1},offset:{u:0,v:0,w:0},scale:{u:1,v:1,w:1},turbulence:{u:0,v:0,w:0},clamp:!1,textureResolution:null,bumpMultiplier:1,imfChan:null,filename:""};let s,a;const r={};for(e.reverse();e.length;){const t=e.pop();t.startsWith("-")?(s=t.substr(1),r[s]=[]):s&&r[s].push(t)}for(s in r){if(!r.hasOwnProperty(s))continue;a=r[s];const e=this[`parse_${s}`];e&&e.bind(this)(a,t)}return t}parseMap(e){let t,s="";e[0].startsWith("-")?(s=e.pop(),t=e):[s,...t]=e;const a=this.parseOptions(t);return a.filename=s.replace(/\\/g,"/"),a}parse_map_Ka(e){this.currentMaterial.mapAmbient=this.parseMap(e)}parse_map_Kd(e){this.currentMaterial.mapDiffuse=this.parseMap(e)}parse_map_Ks(e){this.currentMaterial.mapSpecular=this.parseMap(e)}parse_map_Ke(e){this.currentMaterial.mapEmissive=this.parseMap(e)}parse_map_Ns(e){this.currentMaterial.mapSpecularExponent=this.parseMap(e)}parse_map_d(e){this.currentMaterial.mapDissolve=this.parseMap(e)}parse_map_aat(e){this.currentMaterial.antiAliasing="on"==e[0]}parse_map_bump(e){this.currentMaterial.mapBump=this.parseMap(e)}parse_bump(e){this.parse_map_bump(e)}parse_disp(e){this.currentMaterial.mapDisplacement=this.parseMap(e)}parse_decal(e){this.currentMaterial.mapDecal=this.parseMap(e)}parse_refl(e){this.currentMaterial.mapReflections.push(this.parseMap(e))}parse(){const e=this.data.split(/\r?\n/);for(let t of e){if(t=t.trim(),!t||t.startsWith("#"))continue;const[e,...s]=t.split(/\s/),a=this[`parse_${e}`];a?a.bind(this)(s):console.warn(`Don't know how to parse the directive: "${e}"`)}this.data="",this.currentMaterial=c}}function h(e,t){const s=["mapDiffuse","mapAmbient","mapSpecular","mapDissolve","mapBump","mapDisplacement","mapDecal","mapEmissive"];t.endsWith("/")||(t+="/");const a=[];for(const r in e.materials){if(!e.materials.hasOwnProperty(r))continue;const i=e.materials[r];for(const e of s){const s=i[e];if(!s||!s.filename)continue;const r=t+s.filename;a.push(fetch(r).then((e=>{if(!e.ok)throw new Error;return e.blob()})).then((function(e){const t=new Image;return t.src=URL.createObjectURL(e),s.texture=t,new Promise((e=>t.onload=e))})).catch((()=>{console.error(`Unable to download texture: ${r}`)})))}}return Promise.all(a)}function p(e){const t=[];for(const a of e){if(!a.obj)throw new Error('"obj" attribute of model object not set. The .obj file is required to be set in order to use downloadModels()');const e={indicesPerMaterial:!!a.indicesPerMaterial,calcTangentsAndBitangents:!!a.calcTangentsAndBitangents};let r=a.name;if(!r){const e=a.obj.split("/");r=e[e.length-1].replace(".obj","")}const i=Promise.resolve(r),o=fetch(a.obj).then((e=>e.text())).then((t=>new n(t,e)));let l;if(a.mtl){const e="string"!=typeof(s=a).mtl?s.obj.replace(/\.obj$/,".mtl"):s.mtl;l=fetch(e).then((e=>e.text())).then((t=>{const s=new u(t);if(!1!==a.downloadMtlTextures){let t=a.mtlTextureRoot;return t||(t=e.substr(0,e.lastIndexOf("/"))),Promise.all([Promise.resolve(s),h(s,t)])}return Promise.all([Promise.resolve(s),void 0])})).then((e=>e[0]))}const c=[i,o,l];t.push(Promise.all(c))}var s;return Promise.all(t).then((e=>{const t={};for(const s of e){const[e,a,r]=s;a.name=e,r&&a.addMaterialLibrary(r),t[e]=a}return t}))}function m(e,t,s){void 0===s&&(s={});const a=[];for(const t in e){if(!e.hasOwnProperty(t))continue;const s=e[t];a.push(fetch(s).then((e=>e.text())).then((e=>[t,new n(e)])))}Promise.all(a).then((e=>{for(const[t,a]of e)s[t]=a;return t(s)}))}function f(e,t,s,a){const r=e.createBuffer(),i=t===e.ARRAY_BUFFER?Float32Array:Uint16Array;return e.bindBuffer(t,r),e.bufferData(t,new i(s),e.STATIC_DRAW),r.itemSize=a,r.numItems=s.length/a,r}function d(e,t){return t.normalBuffer=f(e,e.ARRAY_BUFFER,t.vertexNormals,3),t.textureBuffer=f(e,e.ARRAY_BUFFER,t.textures,t.textureStride),t.vertexBuffer=f(e,e.ARRAY_BUFFER,t.vertices,3),t.indexBuffer=f(e,e.ELEMENT_ARRAY_BUFFER,t.indices,1),t}function M(e,t){e.deleteBuffer(t.normalBuffer),e.deleteBuffer(t.textureBuffer),e.deleteBuffer(t.vertexBuffer),e.deleteBuffer(t.indexBuffer)}const b="2.0.3",v={Attribute:r,DuplicateAttributeException:a,Layout:i,Material:l,MaterialLibrary:u,Mesh:n,TYPES:e,downloadModels:p,downloadMeshes:m,initMeshBuffers:d,deleteMeshBuffers:M,version:b};var g=s.ah,x=s.i1,w=s.Ar,y=s.F5,T=s.Jc,I=s.Kj,A=s.NQ,E=s.vK,S=s.R9,B=s.Ml,_=s.LT,F=s.cP,N=s.i8;export{g as Attribute,x as DuplicateAttributeException,w as Layout,y as Material,T as MaterialLibrary,I as Mesh,A as OBJ,E as TYPES,S as deleteMeshBuffers,B as downloadMeshes,_ as downloadModels,F as initMeshBuffers,N as version};